package discrete_test

import (
	"fmt"
	"math"
	"testing"

	"github.com/kzahedi/goent/discrete"
)

func random3D() [][][]float64 {
	d := make([][][]float64, 2, 2)
	for i := 0; i < 2; i++ {
		d[i] = make([][]float64, 2, 2)
		for j := 0; j < 2; j++ {
			d[i][j] = make([]float64, 2, 2)
		}
	}

	// number generated by mathematica
	d[0][0][0] = 0.16368852271549625
	d[0][0][1] = 0.06376901757394152
	d[0][1][0] = 0.1665988153736691
	d[0][1][1] = 0.10434124349128561
	d[1][0][0] = 0.06763873914824399
	d[1][0][1] = 0.23773709094595946
	d[1][1][0] = 0.1802225946987888
	d[1][1][1] = 0.01600397605261524

	return d
}

func random2D() [][]float64 {
	d := make([][]float64, 2, 2)
	for i := 0; i < 2; i++ {
		d[i] = make([]float64, 2, 2)
	}

	// number generated by mathematica
	d[0][0] = 0.38545682823650396
	d[0][1] = 0.03333130265730018
	d[1][0] = 0.5150147316756242
	d[1][1] = 0.0661971374305717

	return d
}

func random1D() []float64 {
	d := make([]float64, 2, 2)

	// number generated by mathematica
	d[0] = 0.4739196991545937
	d[1] = 0.5260803008454062

	return d
}

func TestPX(t *testing.T) {
	p := random3D()
	r := discrete.PX(p)
	s := []float64{0.498398, 0.501602}
	check1D(r, s, "PX", t)
}

func TestPY(t *testing.T) {
	p := random3D()
	r := discrete.PY(p)
	s := []float64{0.532833, 0.467167}
	check1D(r, s, "PY", t)
}

func TestPZ(t *testing.T) {
	p := random3D()
	r := discrete.PZ(p)
	s := []float64{0.578149, 0.421851}
	check1D(r, s, "PZ", t)
}

func TestPYZ(t *testing.T) {
	p := random3D()
	r := discrete.PYZ(p)
	s := [][]float64{{0.231327, 0.301506}, {0.346821, 0.120345}}
	check2D(r, s, "PYZ", t)
}

func TestPXZ(t *testing.T) {
	p := random3D()
	r := discrete.PXZ(p)
	s := [][]float64{{0.330287, 0.16811}, {0.247861, 0.253741}}
	check2D(r, s, "PXZ", t)
}

func TestPXY(t *testing.T) {
	p := random3D()
	r := discrete.PXY(p)
	s := [][]float64{{0.227458, 0.27094}, {0.305376, 0.196227}}
	check2D(r, s, "PXY", t)
}

func TestH3(t *testing.T) {
	p := random3D()
	r := discrete.H3(p)
	// result taken from a working implementation in Mathematica
	if math.Abs(r-2.74816) > 0.0001 {
		t.Errorf(fmt.Sprintf("H3 should be %f, but it is %f", 2.74816, r))
	}
}

func TestH2(t *testing.T) {
	p := random2D()
	r := discrete.H2(p)
	// result taken from a working implementation in Mathematica
	if math.Abs(r-1.44603) > 0.0001 {
		t.Errorf(fmt.Sprintf("H3 should be %f, but it is %f", 1.44603, r))
	}
}

func TestH1(t *testing.T) {
	p := random1D()
	r := discrete.H1(p)

	if math.Abs(r-0.998037) > 0.0001 {
		t.Errorf(fmt.Sprintf("H1 of uniform should be %f, but it is %f", 0.998037, r))
	}
}

func TestMiXvYgZ(t *testing.T) {
	p := random3D()
	s := 0.138276
	r := discrete.MiXvYgZ(p)
	if math.Abs(r-s) > 0.0001 {
		t.Errorf(fmt.Sprintf("MiXvYgZ should be %f, but it is %f", s, r))
	}
}

func TestMiXvZgY(t *testing.T) {
	p := random3D()
	s := 0.142503
	r := discrete.MiXvZgY(p)
	if math.Abs(r-s) > 0.0001 {
		t.Errorf(fmt.Sprintf("MiXvZgY should be %f, but it is %f", s, r))
	}
}

func TestMiXvY(t *testing.T) {
	p := random3D()
	s := 0.0168978
	r := discrete.MiXvY(p)
	if math.Abs(r-s) > 0.0001 {
		t.Errorf(fmt.Sprintf("MiXvY should be %f, but it is %f", s, r))
	}
}

func TestCoI(t *testing.T) {
	p := random3D()
	s := discrete.MiXvY(p) - discrete.MiXvYgZ(p)
	r := discrete.CoI(p)
	if math.Abs(r-s) > 0.0001 {
		t.Errorf(fmt.Sprintf("CoI should be %f, but it is %f", s, r))
	}
}

func TestPt(t *testing.T) {
	p := random3D()

	A := make([][][]float64, 2, 2)
	A[0] = make([][]float64, 2, 2)
	A[1] = make([][]float64, 2, 2)
	A[0][0] = make([]float64, 2, 2)
	A[0][1] = make([]float64, 2, 2)
	A[1][0] = make([]float64, 2, 2)
	A[1][1] = make([]float64, 2, 2)

	B := make([][][]float64, 2, 2)
	B[0] = make([][]float64, 2, 2)
	B[1] = make([][]float64, 2, 2)
	B[0][0] = make([]float64, 2, 2)
	B[0][1] = make([]float64, 2, 2)
	B[1][0] = make([]float64, 2, 2)
	B[1][1] = make([]float64, 2, 2)

	A[0][0][0] = 1.0
	A[0][0][1] = -1.0
	A[0][1][0] = -1.0
	A[0][1][1] = 1.0

	B[1][0][0] = 1.0
	B[1][0][1] = -1.0
	B[1][1][0] = -1.0
	B[1][1][1] = 1.0

	// Numbers generated with a working Mathematica implementation
	r := discrete.Pt(p, -1.0, 1.0)
	s := [][][]float64{{{-0.836311, 1.06377}, {1.1666, -0.895659}}, {{1.06764, -0.762263}, {-0.819777, 1.016}}}
	check3D(r, s, "Pt", t)

	r = discrete.Pt(p, -1.0, -1.0)
	s = [][][]float64{{{-0.836311, 1.06377}, {1.1666, -0.895659}}, {{-0.932361, 1.23774}, {1.18022, -0.983996}}}
	check3D(r, s, "Pt", t)

	r = discrete.Pt(p, 1.0, -1.0)
	s = [][][]float64{{{1.16369, -0.936231}, {-0.833401, 1.10434}}, {{-0.932361, 1.23774}, {1.18022, -0.983996}}}
	check3D(r, s, "Pt", t)

	r = discrete.Pt(p, 1.0, 1.0)
	s = [][][]float64{{{1.16369, -0.936231}, {-0.833401, 1.10434}}, {{1.06764, -0.762263}, {-0.819777, 1.016}}}
	check3D(r, s, "Pt", t)
}

func TestID(t *testing.T) {
	p := random3D()
	a, b, c := discrete.InformationDecomposition(p, 100)

	if math.Abs(a-0.1376) > 0.0001 {
		t.Errorf(fmt.Sprintf("Synergy should be %f, but it is %f", 0.1376, a))
	}

	if math.Abs(b-0.000676248) > 0.0001 {
		t.Errorf(fmt.Sprintf("UniqueXY should be %f, but it is %f", 0.000676248, b))
	}

	if math.Abs(c-0.00490289) > 0.0001 {
		t.Errorf(fmt.Sprintf("UniqueXZ should be %f, but it is %f", 0.00490289, c))
	}

}

func check3D(r, s [][][]float64, label string, t *testing.T) {
	for i := 0; i < 2; i++ {
		for j := 0; j < 2; j++ {
			for k := 0; k < 2; k++ {
				if math.Abs(r[i][j][k]-s[i][j][k]) > 0.0001 {
					t.Errorf(fmt.Sprintf("%s should be %f, but it is %f", label, s[i][j][k], r[i][j][k]))
				}
			}
		}
	}
}

func check2D(r, s [][]float64, label string, t *testing.T) {
	for i := 0; i < 2; i++ {
		for j := 0; j < 2; j++ {
			if math.Abs(r[i][j]-s[i][j]) > 0.0001 {
				t.Errorf(fmt.Sprintf("%s should be %f, but it is %f", label, s[i][j], r[i][j]))
			}
		}
	}
}

func check1D(r, s []float64, label string, t *testing.T) {
	for i := 0; i < 2; i++ {
		if math.Abs(r[i]-s[i]) > 0.0001 {
			t.Errorf(fmt.Sprintf("%s should be %f, but it is %f", label, s[i], r[i]))
		}
	}
}
